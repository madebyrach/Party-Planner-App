<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portion & Drink Calculator</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for aesthetic enhancements */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f9fb; /* Light background */
        }
        .card {
            box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.05), 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            transition: transform 0.2s;
        }
        .input-style {
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            width: 100%;
            transition: border-color 0.2s, box-shadow 0.2s;
        }
        .input-style:focus {
            border-color: #3b82f6; /* Blue-500 */
            outline: none;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.25);
        }
        .btn-primary {
            background-color: #3b82f6;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }
        .btn-primary:hover {
            background-color: #2563eb;
            transform: translateY(-1px);
        }
        .tab-btn {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem 0.5rem 0 0;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s;
        }
        .tab-btn.active {
            background-color: #ffffff;
            color: #1d4ed8; /* Blue-700 */
            border-bottom: 2px solid #3b82f6;
        }
        .tab-btn:not(.active) {
            background-color: #e5e7eb; /* Gray-200 */
            color: #6b7280; /* Gray-500 */
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #fff;
            width: 1.5rem;
            height: 1.5rem;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

    <div class="max-w-4xl mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-10">
            <h1 class="text-4xl font-extrabold text-gray-900 mb-2">Recipe & Party Planner</h1>
            <p class="text-xl text-gray-500">Plan your party.</p>
        </header>

        <div class="card bg-white rounded-xl overflow-hidden">
            <!-- Tabs -->
            <div class="flex border-b border-gray-200">
                <button id="tab-portion" class="tab-btn active" onclick="showTab('portion')">
                    Menu Optimizer
                </button>
                <button id="tab-drink" class="tab-btn" onclick="showTab('drink')">
                    Drink Quantity Estimator
                </button>
            </div>

            <!-- Tab Content: Menu Optimizer -->
            <div id="content-portion" class="p-6">
                <h2 class="text-2xl font-semibold mb-6 text-blue-700">Identify your shopping list</h2>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <!-- 1. Guest Count -->
                    <div>
                        <label for="num-people" class="block text-sm font-medium text-gray-700 mb-1">Total Number of Guests</label>
                        <input type="number" id="num-people" value="10" min="1" class="input-style">
                    </div>
                    
                    <!-- 2. List of Foods -->
                    <div class="md:col-span-2">
                        <label for="food-list-input" class="block text-sm font-medium text-gray-700 mb-1">List of Foods (One item per line)</label>
                        <textarea id="food-list-input" class="input-style h-32" placeholder="e.g.,&#10;Chicken Wings&#10;Potato Salad&#10;Pizza Slices&#10;Brownies">Chicken Wings
Caesar Salad
Veggie Burgers
Soda Cans</textarea>
                    </div>

                    <!-- 3. Event Notes -->
                    <div class="md:col-span-2">
                        <label for="event-notes" class="block text-sm font-medium text-gray-700 mb-1">Dietary/Event Notes</label>
                        <textarea id="event-notes" class="input-style h-20" placeholder="e.g., We have 1 vegetarian, 5 kids, and need no leftovers.">Party lasts 4 hours. 2 guests are vegetarian.</textarea>
                    </div>
                </div>
                
                <!-- Action Button -->
                <div class="text-center mb-6">
                    <button id="ai-optimize-btn" onclick="getFinalMenuOptimization()" class="btn-primary flex items-center justify-center mx-auto w-full md:w-2/3 bg-indigo-600 hover:bg-indigo-700">
                        <span id="ai-optimize-btn-text">Optimize Menu & Get Shopping List</span>
                        <div id="ai-optimize-loading-spinner" class="loading-spinner hidden ml-2"></div>
                    </button>
                </div>

                <!-- AI Optimization Notes -->
                <div id="optimization-notes" class="p-3 bg-yellow-100 border border-yellow-300 rounded-lg text-sm text-gray-700 hidden mb-6">
                    <!-- Optimization notes will be placed here -->
                </div>
                
                <!-- Display Results -->
                <h3 class="text-xl font-medium mb-3 text-gray-700 border-b pb-2">Final Optimized Shopping List</h3>
                <ul id="ingredient-list" class="space-y-3">
                    <!-- Optimized list will be injected here -->
                </ul>
                <div id="no-ingredients-message" class="text-center p-4 text-gray-500 italic">
                    Enter your list and notes above, then click 'Optimize Menu'.
                </div>
            </div>

            <!-- Tab Content: Drink Estimator (NEW AI LOGIC) -->
            <div id="content-drink" class="p-6 hidden">
                <h2 class="text-2xl font-semibold mb-4 text-blue-700">Drink Estimator</h2>
                <p class="text-sm text-gray-600 mb-6">
                    Enter the event details, and we will calculate and suggest a tailored drink menu and quantities based on the occasion and duration.
                </p>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
                    <div>
                        <label for="num-guests-drink" class="block text-sm font-medium text-gray-700 mb-1">Total Number of Guests</label>
                        <input type="number" id="num-guests-drink" value="15" min="1" class="input-style">
                    </div>
                    <div>
                        <label for="event-duration" class="block text-sm font-medium text-gray-700 mb-1">Approximate Duration (Hours)</label>
                        <input type="number" id="event-duration" value="3.5" min="0.5" step="0.5" class="input-style">
                    </div>
                </div>
                
                <div class="mb-6">
                    <label for="event-description" class="block text-sm font-medium text-gray-700 mb-1">Describe the Event (Type of party, guest age range, focus of drinks)</label>
                    <textarea id="event-description" class="input-style h-24" placeholder="e.g., Casual BBQ, 20 adults, mostly beer drinkers. OR Kids birthday party, 5 adults, no alcohol needed.">Holiday party for 15 adults (3 non-drinkers). Needs a mix of beer, wine, and water.</textarea>
                </div>

                <div class="text-center mb-6">
                    <button id="ai-drink-btn" onclick="calculateDrinksWithAI()" class="btn-primary flex items-center justify-center mx-auto w-full md:w-2/3 bg-green-600 hover:bg-green-700">
                        <span id="ai-drink-btn-text">Estimate Drinks Needed</span>
                        <div id="ai-drink-loading-spinner" class="loading-spinner hidden ml-2"></div>
                    </button>
                </div>

                <!-- Display Results -->
                <div id="drink-results" class="space-y-4 pt-4 border-t border-gray-200">
                    <h3 class="text-xl font-medium text-gray-700 mb-3">AI Drink Recommendation</h3>
                     <div id="drink-summary-output" class="p-3 bg-blue-50 border border-blue-200 rounded-lg text-sm text-gray-700 hidden mb-4">
                        <!-- AI analysis and summary goes here -->
                    </div>
                    
                    <h4 class="text-lg font-semibold text-gray-700 mt-6">Suggested Shopping List Breakdown</h4>
                    <ul id="breakdown-output" class="list-disc list-inside space-y-2 ml-4 text-gray-700">
                        <!-- Breakdown here -->
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Data Store for Portion Calculator. 
        let optimizedIngredients = [];

        // Backend Proxy Configuration
        // NOTE: The frontend now communicates with a local proxy server.
        const PROXY_URL_OPTIMIZE = 'http://localhost:3000/api/optimize';
        const PROXY_URL_DRINKS = 'http://localhost:3000/api/drinks';

        /**
         * Utility function to safely get numeric input value.
         * @param {string} id - The ID of the input element.
         * @returns {number} The parsed float value, or 0 if invalid.
         */
        function getNumberValue(id) {
            const element = document.getElementById(id);
            if (!element) return 0;
            const value = parseFloat(element.value);
            return isNaN(value) || value < 0 ? 0 : value;
        }

        /**
         * Exponential backoff for API retries.
         * We now retry calls to the local proxy.
         * @param {function} fn - The async function to call.
         * @param {number} maxRetries - Maximum number of retries.
         */
        async function exponentialBackoffFetch(fn, maxRetries = 3) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    return await fn();
                } catch (error) {
                    if (i === maxRetries - 1) throw error;
                    const delay = Math.pow(2, i) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }
        
        /**
         * Helper to find and extract the outermost JSON object from a string.
         * This handles cases where the AI wraps the JSON in text or markdown fences.
         * @param {string} rawText - The raw string from the AI.
         * @returns {string} The cleaned JSON string, or null if not found.
         */
        function cleanJsonString(rawText) {
            if (!rawText) return null;
            
            // Find the index of the first '{' and the last '}'
            const start = rawText.indexOf('{');
            const end = rawText.lastIndexOf('}');
            
            if (start !== -1 && end !== -1 && end > start) {
                // Slice the string to include only the content between (and including) the first '{' and last '}'
                return rawText.substring(start, end + 1).trim();
            }
            return null; // No valid JSON structure found
        }

        // --- Menu Optimizer Functions ---
        
        /**
         * Calls the local proxy server to optimize the entire menu based on all inputs.
         */
        async function getFinalMenuOptimization() {
            const numPeople = getNumberValue('num-people');
            const foodListRaw = document.getElementById('food-list-input').value.trim();
            const eventNotes = document.getElementById('event-notes').value.trim();
            
            const optimizeButton = document.getElementById('ai-optimize-btn');
            const buttonText = document.getElementById('ai-optimize-btn-text');
            const loadingSpinner = document.getElementById('ai-optimize-loading-spinner');
            const notesDisplay = document.getElementById('optimization-notes');

            if (!foodListRaw) {
                notesDisplay.innerHTML = 'Please enter a list of food items.';
                notesDisplay.classList.remove('hidden');
                return;
            }
            if (numPeople <= 0) {
                 notesDisplay.innerHTML = 'Please enter a valid number of guests.';
                 notesDisplay.classList.remove('hidden');
                 return;
            }
            
            // UI: Set loading state
            loadingSpinner.classList.remove('hidden');
            buttonText.textContent = 'Optimizing...';
            optimizeButton.disabled = true;
            notesDisplay.classList.add('hidden');
            optimizedIngredients = []; // Clear previous results
            renderOptimizedPortions();

            const foodList = foodListRaw.split('\n')
                                        .map(line => line.trim())
                                        .filter(line => line.length > 0);

            // Response schema is sent to the backend proxy
            const responseSchema = {
                type: "OBJECT",
                properties: {
                    "optimized_ingredients": { 
                        "type": "ARRAY",
                        "description": "The final shopping list with the total quantities needed for the entire event.",
                        "items": {
                             "type": "OBJECT",
                             "properties": {
                                "total_qty": { "type": "NUMBER", "description": "The final, total quantity required for the event (e.g., 20, 1.5)." },
                                "unit": { "type": "STRING", "description": "The unit (e.g., 'pcs', 'oz', 'kg', 'bottles', 'cans')." },
                                "name": { "type": "STRING", "description": "The name of the item." }
                             },
                             "required": ["total_qty", "unit", "name"]
                        }
                    },
                    "optimization_notes": { 
                        "type": "STRING", 
                        "description": "A brief, conversational summary explaining the adjustments made, focusing on how the notes influenced the final quantities." 
                    }
                },
                required: ["optimized_ingredients", "optimization_notes"]
            };

            const userQuery = `
                Generate a final shopping list for the following. Utilize the event notes to make reasonable modifications. Make sure to separate out ingredients when it makes sense. For example, if user inputs "caesar salad", put separate amounnts for each caesar salad ingredient:
                - Total Guests: ${numPeople}
                - Initial Food List (Items only): ${JSON.stringify(foodList)}
                - Event Notes: "${eventNotes}"
            `;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: responseSchema
                }
            };

            try {
                const response = await exponentialBackoffFetch(async () => {
                    // Send request to your local proxy server
                    const res = await fetch(PROXY_URL_OPTIMIZE, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(`Proxy error: ${errorData.error || 'Unknown error'}. Make sure your backend server is running.`);
                    }
                    return res;
                });
                
                const result = await response.json();
                
                // The proxy returns the raw Gemini response structure
                let rawJsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                let jsonText = cleanJsonString(rawJsonText);
                
                if (jsonText) {
                    let parsedJson;
                    try {
                         parsedJson = JSON.parse(jsonText);
                    } catch (e) {
                         console.error("CRITICAL: Failed to parse JSON response. Raw Text from AI:", rawJsonText);
                         throw new Error("AI returned content, but it was not valid JSON format.");
                    }
                    
                    optimizedIngredients = parsedJson.optimized_ingredients;
                    
                    notesDisplay.innerHTML = `<p class="font-bold">Summary:</p><p>${parsedJson.optimization_notes}</p>`;
                    notesDisplay.classList.remove('hidden');

                    renderOptimizedPortions(); 
                    
                    buttonText.textContent = 'Optimization Complete';
                } else {
                    console.error("AI response was empty or malformed at the candidate level. Raw Text:", rawJsonText);
                    throw new Error("AI response was empty or malformed at the candidate level.");
                }

            } catch (error) {
                console.error("Error during menu optimization:", error.message);
                notesDisplay.innerHTML = `Optimization failed: ${error.message}`;
                notesDisplay.classList.remove('hidden');
                buttonText.textContent = 'Optimization Failed';
            } finally {
                loadingSpinner.classList.add('hidden');
                optimizeButton.disabled = false;
                setTimeout(() => {
                    if(buttonText.textContent !== 'Optimization Failed') {
                        buttonText.textContent = 'Optimize Menu & Get Shopping List';
                    }
                }, 4000);
            }
        }


        /**
         * Renders the final, total optimized quantities (called after AI optimization).
         */
        function renderOptimizedPortions() {
            const listElement = document.getElementById('ingredient-list');
            const noIngredientsMsg = document.getElementById('no-ingredients-message');
            
            listElement.innerHTML = '';
            
            if (optimizedIngredients.length === 0) {
                noIngredientsMsg.classList.remove('hidden');
                return;
            }
            noIngredientsMsg.classList.add('hidden');

            optimizedIngredients.forEach((item) => {
                const isPieceUnit = ['pcs', 'pieces', 'slices', 'burgers', 'wings', 'tacos', 'bottles', 'cans'].includes(item.unit.toLowerCase());

                const formattedQty = isPieceUnit
                    ? Math.ceil(item.total_qty) 
                    : item.total_qty.toFixed(2);

                const listItem = document.createElement('li');
                listItem.className = 'flex items-center justify-between p-4 bg-white rounded-lg border border-blue-100 shadow-md';
                listItem.innerHTML = `
                    <div class="flex-grow">
                        <span class="text-2xl font-extrabold text-blue-800">${formattedQty}</span>
                        <span class="text-lg text-gray-600 ml-1">${item.unit}</span>
                        <span class="text-xl font-medium text-gray-900 ml-3">${item.name}</span>
                    </div>
                `;
                listElement.appendChild(listItem);
            });
        }
        
        // --- Drink Estimator Functions ---

        /**
         * Calls the local proxy server to calculate drink needs based on event context.
         */
        async function calculateDrinksWithAI() {
            const numGuests = getNumberValue('num-guests-drink'); 
            const durationHours = getNumberValue('event-duration');
            const eventDescription = document.getElementById('event-description').value.trim();

            const estimateButton = document.getElementById('ai-drink-btn');
            const buttonText = document.getElementById('ai-drink-btn-text');
            const loadingSpinner = document.getElementById('ai-drink-loading-spinner');
            const breakdownOutput = document.getElementById('breakdown-output');
            const summaryOutput = document.getElementById('drink-summary-output');

            breakdownOutput.innerHTML = '';
            summaryOutput.classList.add('hidden');

            if (numGuests <= 0 || durationHours <= 0 || !eventDescription) {
                summaryOutput.innerHTML = 'Please enter valid numbers for guests and duration, and describe the event.';
                summaryOutput.classList.remove('hidden');
                return;
            }

            // UI: Set loading state
            loadingSpinner.classList.remove('hidden');
            buttonText.textContent = 'Estimating...';
            estimateButton.disabled = true;

            // Response schema is sent to the backend proxy
            const responseSchema = {
                type: "OBJECT",
                properties: {
                    "summary_analysis": { 
                        "type": "STRING", 
                        "description": "A brief, conversational summary explaining the estimation logic (e.g., 'Assuming 12 adults will drink at a moderate rate of 1.2 drinks per hour...')." 
                    },
                    "drink_shopping_list": { 
                        "type": "ARRAY",
                        "description": "The final shopping list for drinks.",
                        "items": {
                             "type": "OBJECT",
                             "properties": {
                                "item": { "type": "STRING", "description": "The type of drink (e.g., Sparkling Water, IPA Beer, Red Wine)." },
                                "total_qty": { "type": "NUMBER", "description": "The final, total quantity required (e.g., 20, 1.5)." },
                                "unit": { "type": "STRING", "description": "The unit of purchase (e.g., 'bottles', 'cases', 'Liters')." }
                             },
                             "required": ["item", "total_qty", "unit"]
                        }
                    }
                },
                required: ["summary_analysis", "drink_shopping_list"]
            };

            const userQuery = `
                Estimate the drink shopping list for the following event:
                - Total Guests: ${numGuests}
                - Event Duration: ${durationHours} hours
                - Event Description: "${eventDescription}"
            `;

            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                tools: [{ "google_search": {} }],
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: responseSchema
                }
            };

            try {
                const response = await exponentialBackoffFetch(async () => {
                    // Send request to your local proxy server
                    const res = await fetch(PROXY_URL_DRINKS, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(`Proxy error: ${errorData.error || 'Unknown error'}. Make sure your backend server is running.`);
                    }
                    return res;
                });
                
                const result = await response.json();
                
                // The proxy returns the raw Gemini response structure
                let rawJsonText = result.candidates?.[0]?.content?.parts?.[0]?.text;
                let jsonText = cleanJsonString(rawJsonText);
                
                if (jsonText) {
                    let parsedJson;
                    try {
                         parsedJson = JSON.parse(jsonText);
                    } catch (e) {
                         console.error("CRITICAL: Failed to parse JSON response. Raw Text from AI:", rawJsonText);
                         throw new Error("AI returned content, but it was not valid JSON format.");
                    }
                    
                    // 1. Display Analysis/Summary
                    summaryOutput.innerHTML = `<p class="font-bold">Estimation Analysis:</p><p>${parsedJson.summary_analysis}</p>`;
                    summaryOutput.classList.remove('hidden');

                    // 2. Display Shopping List Breakdown
                    parsedJson.drink_shopping_list.forEach(drink => {
                        const isPieceUnit = ['bottles', 'cans', 'cases', 'packs'].includes(drink.unit.toLowerCase());
                        const formattedQty = isPieceUnit
                            ? Math.ceil(drink.total_qty) 
                            : drink.total_qty.toFixed(1);
                        
                        const listItem = document.createElement('li');
                        listItem.className = 'flex items-center justify-between p-2 bg-gray-50 rounded-lg';
                        listItem.innerHTML = `
                             <span class="text-lg font-bold text-green-700">${formattedQty}</span>
                             <span class="text-md text-gray-600 ml-1">${drink.unit}</span>
                             <span class="text-lg font-medium text-gray-900 ml-3">${drink.item}</span>
                        `;
                        breakdownOutput.appendChild(listItem);
                    });
                    
                    buttonText.textContent = 'Estimate Complete';
                } else {
                    console.error("AI response was empty or malformed at the candidate level. Raw Text:", rawJsonText);
                    throw new Error("AI response was empty or malformed at the candidate level.");
                }

            } catch (error) {
                console.error("Error during drink estimation:", error.message);
                summaryOutput.innerHTML = `Drink estimation failed: ${error.message}`;
                summaryOutput.classList.remove('hidden');
                buttonText.textContent = 'Estimation Failed';
            } finally {
                // UI: Reset loading state
                loadingSpinner.classList.add('hidden');
                estimateButton.disabled = false;
                setTimeout(() => {
                    if(buttonText.textContent !== 'Estimation Failed') {
                        buttonText.textContent = 'Estimate Drinks Needed';
                    }
                }, 4000);
            }
        }


        /**
         * Switches the active tab content.
         * @param {string} tabName - 'portion' or 'drink'.
         */
        function showTab(tabName) {
            document.getElementById('content-portion').classList.toggle('hidden', tabName !== 'portion');
            document.getElementById('content-drink').classList.toggle('hidden', tabName !== 'drink');

            document.getElementById('tab-portion').classList.toggle('active', tabName === 'portion');
            document.getElementById('tab-drink').classList.toggle('active', tabName === 'drink');
        }


        // --- Initialization ---

        window.onload = function() {
            // Initial render for the menu tab (which uses the pre-filled mock data)
            renderOptimizedPortions();
        };

    </script>
</body>
</html>